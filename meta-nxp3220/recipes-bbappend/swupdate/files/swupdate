#! /bin/sh
### BEGIN INIT INFO
# Provides:          swupdate
# Required-Start:    $local_fs
# Should-Start:
# Required-Stop:     $local_fs
# Should-Stop:
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Start swupdate application
### END INIT INFO

# The definition of actions: (From LSB 3.1.0)
# start         start the service
# stop          stop the service
# restart       stop and restart the service if the service is already running,
#               otherwise start the service
# try-restart	restart the service if the service is already running
# force-reload	cause the configuration to be reloaded if the service supports
#               this, otherwise restart the service if it is running
# status	print the current status of the service

# The start, stop, restart, force-reload, and status actions shall be supported
# by all init scripts; the reload and the try-restart actions are optional

# PATH should only include /usr/* if it runs after the mountnfs.sh script
PATH=/sbin:/usr/sbin:/bin:/usr/bin

DESC="swupdate"
NAME="swupdate"
PROG=/usr/bin/swupdate
PIDFILE=/var/run/$NAME.pid
LOGFILE=/dev/console	# /var/log/swupdate.log

. /etc/init.d/functions || exit 1

# Exit if the package is not installed
[ -x "$PROG" ] || exit 0

# Read configuration variable file if it is present
[ -r /etc/default/$NAME ] && . /etc/default/$NAME

MOUNT_PATH="/mnt"
SIGN_KEY="/misc/etc/swu.public.key"
EXEC_COMMAND="$PROG -k $SIGN_KEY -i $MOUNT_PATH/*.swu -v $SWUPDATE_EXTRA_ARGS"

#
# Function that starts the daemon/service
#
do_start() {
	local status pid
	local device=$1

	if [ -z "$device" ]; then
		echo "SWUpdate: Not connected cards [sd/usb] !!!" > $LOGFILE
		exit 1;
	fi	

	echo "SWU mount dev/$device -> $MOUNT_PATH" > $LOGFILE
	mount /dev/$device -o rw $MOUNT_PATH
	wait;

	status=0
	pid=`pidofproc $NAME` || status=$?
	case $status in
	0)
		echo "$DESC already running ($pid)." > $LOGFILE
		exit 1
		;;
	*)
		echo "Starting $DESC ..." > $LOGFILE
		exec $EXEC_COMMAND > $LOGFILE  &
		exit 0
		;;
	esac
}

#
# Function that stops the daemon/service
#
do_stop() {
	local pid status
	local device=$1

	if [ ! -z "$device" ]; then
		mount | grep mnt | grep $device
		if [ $? -eq 0 ]; then
			echo "SWU umount $MOUNT_PATH" > $LOGFILE
			umount $MOUNT_PATH
			wait;
		fi
	fi

	status=0
	pid=`pidofproc $NAME` || status=$?
	case $status in
	0)
		# Exit when fail to stop, the kill would complain when fail
		kill -s 15 $pid >/dev/null && rm -f $PIDFILE && \
			echo "Stopped $DESC ($pid)." > $LOGFILE || exit $?
		;;
	*)
		echo "$DESC is not running; none killed." >&2
		;;
	esac

	# Wait for children to finish too if this is a daemon that forks
	# and if the daemon is only ever run from this initscript.
	# If the above conditions are not satisfied then add some other code
	# that waits for the process to drop all resources that could be
	# needed by services started subsequently.  A last resort is to
	# sleep for some time.
	return $status
}

#
# Function that shows the daemon/service status
#
status_of_proc () {
	local pid status

	status=0
	# pidof output null when no program is running, so no "2>/dev/null".
	pid=`pidofproc $NAME` || status=$?
	case $status in
	0)
		echo "$DESC is running ($pid)."
		exit 0
		;;
	*)
		echo "$DESC is not running." >&2
		exit $status
		;;
	esac
}

case "$1" in
start)
	do_start "$2"
	;;
stop)
	do_stop "$2" || exit $?
	;;
status)
	status_of_proc
	;;
restart)
	# Always start the service regardless the status of do_stop
	do_stop
	do_start
	;;
try-restart|force-reload)
	# force-reload is the same as reload or try-restart according
	# to its definition, the reload is not implemented here, so
	# force-reload is the alias of try-restart here, but it should
	# be the alias of reload if reload is implemented.
	#
	# Only start the service when do_stop succeeds
	do_stop && do_start
	;;
*)
	echo "Usage: $0 {start|stop|status|restart|try-restart|force-reload} [device node]" >&2
	exit 3
	;;
esac
