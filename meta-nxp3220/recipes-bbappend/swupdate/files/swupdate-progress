#! /bin/sh
### BEGIN INIT INFO
# Provides:          progress
# Required-Start:
# Required-Stop:
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Start psplash application
### END INIT INFO

# The definition of actions: (From LSB 3.1.0)
# start         start the service
# stop          stop the service
# status	print the current status of the service

# The start, stop, restart, force-reload, and status actions shall be supported
# by all init scripts; the reload and the try-restart actions are optional

# PATH should only include /usr/* if it runs after the mountnfs.sh script
PATH=/sbin:/usr/sbin:/bin:/usr/bin

DESC="swupdate-progress"
NAME="swupdate-progress"
PROG=/usr/bin/swupdate-progress
PIDFILE=/var/run/$NAME.pid
LOGFILE=/dev/console	# /var/log/swupdate.log

. /etc/init.d/functions || exit 1

# Exit if the package is not installed
[ -x "$PROG" ] || exit 0

# Read configuration variable file if it is present
[ -r /etc/default/$NAME ] && . /etc/default/$NAME

# -w : wait
# -r : reboot if success
EXEC_COMMAND="$PROG -w -r"

#
# Function that starts the daemon/service
#
if [ ! -e /dev/fb0 ]; then                                                      
    echo "Framebuffer /dev/fb0 not detected"                                    
fi

do_start() {
	local status pid

	status=0
	pid=`pidofproc $NAME` || status=$?
	case $status in
	0)
		echo "$DESC already running ($pid)."
		exit 1
		;;
	*)
		echo "Starting $DESC ..."
		exec $EXEC_COMMAND &
		exit 0
		;;
	esac
}

#
# Function that stops the daemon/service
#
do_stop() {
	local pid status

	status=0
	pid=`pidofproc $NAME` || status=$?
	case $status in
	0)
		# Exit when fail to stop, the kill would complain when fail
		kill -s 15 $pid >/dev/null && rm -f $PIDFILE && \
			echo "Stopped $DESC ($pid)." || exit $?
		;;
	*)
		echo "$DESC is not running; none killed." >&2
		;;
	esac

	# Wait for children to finish too if this is a daemon that forks
	# and if the daemon is only ever run from this initscript.
	# If the above conditions are not satisfied then add some other code
	# that waits for the process to drop all resources that could be
	# needed by services started subsequently.  A last resort is to
	# sleep for some time.
	return $status
}

#
# Function that shows the daemon/service status
#
status_of_proc () {
	local pid status

	status=0
	# pidof output null when no program is running, so no "2>/dev/null".
	pid=`pidofproc $NAME` || status=$?
	case $status in
	0)
		echo "$DESC is running ($pid)."
		exit 0
		;;
	*)
		echo "$DESC is not running." >&2
		exit $status
		;;
	esac
}

echo "SWupdate-progress: $1 ..."
case "$1" in
start)
	do_start
	;;
stop)
	do_stop || exit $?
	;;
status)
	status_of_proc
	;;
*)
	echo "Usage: $0 {start|stop|status|restart|try-restart|force-reload} [device node]" >&2
	exit 3
	;;
esac
